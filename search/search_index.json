{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the UB IEEE Club Wiki","text":"<p>This site contains information about all of the projects run by the University at Buffalo IEEE Student Chapter.</p> <p>Any member of the UB IEEE Club can edit this wiki. If you would like to contribute, see Editing the Wiki.</p> <ul> <li> MicroMouse</li> <li> Battle Bots</li> <li> Arcade Machine</li> <li> Workshops</li> <li> Common Resources</li> </ul>"},{"location":"editing-the-wiki/","title":"Editing the Wiki","text":"<p>This wiki uses mkdocs-material to generate the site html from markdown files.</p> <p>If you would like to add or edit content on this site, first make sure you are familiar with how to use Git and GitHub. If you are new to Git, check out our Git &amp; GitHub Workshop.</p> <p>To make changes, follow these steps:</p> <ol> <li>Create a branch of the wiki repository.</li> <li>Make your changes (add/edit markdown files in <code>docs/</code>). Use Visual Studio Code or your favorite text editor.<ul> <li>If you add a new page, make sure to add it to the <code>nav:</code> section of <code>mkdocs.yml</code> so it shows up in the site navigation.</li> <li>To add abbreviations, add them to <code>includes/abbreviations.md</code>.</li> <li>For markdown syntax help, see this markdown guide.</li> <li>To learn about mkdocs-material features, see the mkdocks-material reference.</li> </ul> </li> <li>To preview the site, you must first install mkdocs-material, then serve the site locally.</li> <li>Commit your changes and push your branch to GitHub.</li> <li>Create a pull request to the <code>main</code> branch of the wiki repository on GitHub.</li> <li>At least one other club member should review your changes, then approve and merge the pull request.</li> <li>After merging, your changes should show up on the site in a few minutes.</li> </ol>"},{"location":"arcade-machine/","title":"Arcade Machine","text":""},{"location":"battlebots/","title":"BattleBots","text":""},{"location":"common-resources/","title":"Common Resources","text":"<p>This is a list of common resources that are expected to be used by members of the club across projects. This  focuses on fundamental technologies and general UB resources. For project specific information, please navigate to the page for your specific project. </p> <ul> <li>School of Engineering and Applied Sciences Machines Shop</li> <li>Git Version Control</li> </ul>"},{"location":"common-resources/git-resources/","title":"Git Resources","text":"<p>This is a list of resources that are helpful to teach yourself git. Many of these resources cover the same content, but we offer a variety of options to fit different learning styles. We recommend that everyone start from the beginning and work your way down as needed unless you have a reason to do otherwise. </p> <p>Git &amp;&amp; GitHub Workshop</p> <p>The workshop slides are great to review if you have attended the workshop, but you probably will not find them helpful if you never attended in person. If you have not attended the workshop, skip the those slides. </p> <p>Git Resources:</p> <ul> <li>IEEE Git &amp;&amp; GitHub Workshop</li> <li>Git in 100 seconds</li> <li>How to Use Git and GitHub</li> <li>Git Mastery Crash Course</li> <li>CS50s Git Lecture</li> <li>Git vs. GitHub</li> <li>The official git textbook</li> <li>Git's documentation: use <code>git --help &lt;command-name-you-need-help-with&gt;</code> or if on UNIX you can also use <code>man git &lt;command-name-you-need-help-with&gt;</code></li> <li>GitHub's documentation</li> </ul>"},{"location":"common-resources/machine-shop/","title":"Machine Shop","text":"<p>The SEAS Machine Shop requires that all users complete a safety training before being able to use the facility. You can visit this link to take the course and become machine shop certified. This course consists of a video lecture followed by a quiz. You must get 100% on the quiz, but you can retake it. This generally should take between one and two hours. </p> <p>You can find more general information about the SEAS Machine Shop here.</p>"},{"location":"micromouse/","title":"MicroMouse","text":""},{"location":"micromouse/#about","title":"About","text":"<p>The MicroMouse competition is one of the oldest robotics competitions in the world. The goal of the competition is to design a robot \"mouse\" that can autonomously navigate and solve a 16x16 cell maze as fast as possible.</p> <p>Check out Veritasium's video on the MicroMouse competition to get an idea of what it's all about:</p>"},{"location":"micromouse/#getting-started","title":"Getting Started","text":"<p>This site contains general knowledge about designing, constructing, and programming MicroMouse robots. Information here will help you build any level of MicroMouse - from simple robots designed completely from COTS parts and 3D printing, to advanced high-speed robots with custom PCBs.</p> <ul> <li> Competition Rules</li> <li> Getting Started</li> <li> MicroMouse Modules</li> <li> Electrical Tips</li> <li> Mechanical Tips</li> <li> Software</li> </ul>"},{"location":"micromouse/competition-rules/","title":"Competition Rules","text":"<p>Most rules are consistent between MicroMouse competitions, such as what your robot is allowed to do and what the maze is like. However, time allowed, number of runs, and scoring may vary.</p> <p>See the following documents to check rules for specific events, or see the following sections on this page for a summary of the most important information:</p> <ul> <li>IEEE Student Competition Rules (2013) PDF</li> <li>APEC MicroMouse Competition Rules (2009) PDF</li> <li>AAMC Rules (2016) PDF</li> </ul>"},{"location":"micromouse/competition-rules/#general-rules","title":"General Rules","text":"<p>The maze always consists of 16x16 cells. The MicroMouse starts in one of the corners and must use only its onboard sensors to navigate the maze. The start cell is always surrounded by walls on three sides. The goal is always a 4-cell area in the center, sometimes with more than one entrance/exit. Maze walls may be freestanding, but there may not be any singular posts except for the one at the center.</p> <p>Each cell of the maze is 18 cm square. Each wall of the maze is 1.2 cm wide and 5 cm tall. The sides of the maze walls are white, the tops of the walls are red, and the floor is black. The maze is made of wood, finished with non-gloss paint. Note that mazes are not always consistent \u2013 your MicroMouse must be able to handle slight differences in the wall and floor.</p> <p>Individual \"runs\" from the start to the goal are timed, and only your fastest run is counted. Normally MicroMouse robots will use their first run to methodically search the maze, gathering as much information as possible while it figures out how to reach the center. Then in subsequent runs, the MicroMouse will try to race to the center as fast as possible, often increasing its speed on each subsequent run until it crashes or time runs out.</p> <p>As far as robot rules go, nothing should be surprising. Your robot must be self-contained (no remote controls), cannot dislodge parts, cannot jump over maze walls, and cannot damage the maze in any way. Your robot cannot be greater than 25 cm in length or width at any time. There is no height constraint. </p> <p>You may not re-program your robot after the maze has been revealed or feed it any information about the maze. You are allowed to press buttons/change the position of switches (e.g. to select algorithms), replace batteries between runs, adjust sensors, change speed settings, and make repairs.</p>"},{"location":"micromouse/competition-rules/#ieee-student-competition-rules","title":"IEEE Student Competition Rules","text":"<p>Most IEEE student competitions follow the same rules, but we recommend you thoroughly review the rules for whatever competition you are attending in case they decide to change anything.</p> <p>Notably, teams must consist of at most 5 students. Teams of 4 and 5 can have up to 2 graduate students, and teams of 2 and 3 can only have one. Single graduate student teams are not allowed. Teams must make a presentation describing how every member made a significant contribution to the team's robot. </p> <p>At IEEE student competitions, each MicroMouse is allowed 10 minutes in the maze to complete as many runs as desired.</p> <p>The fastest run time without being touched will be the official score.</p> <p>If a robot does not reach the center, it is judged based on 1) how close it came to the goal without being touched and 2) Evidence that the mouse knows where it is relative to the goal.</p>"},{"location":"micromouse/competition-rules/#apec-competition-rules","title":"APEC Competition Rules","text":"<p>At the APEC MicroMouse competition, each MicroMouse is allowed 7 minutes in the maze, and may only make 5 runs.</p> <p>APEC applies a \"search penalty\" to your final score, which is 1/30 of your search time (length of your first run from the start to the goal). This incentivizes robots to use a fast search algorithm.</p> <p>There is also a \"touch penalty\" of 2 seconds that will be added to your score if your mouse crashed or needed to be manually restarted prior to your run.</p> <p>The final score is the time of the fastest run, plus the search penalty and touch penalty if touched.</p>"},{"location":"micromouse/getting-started/","title":"Getting Started","text":"<p>Before embarking on this journey of designing a MicroMouse, we must make it clear that creating a MicroMouse is not an easy task and will require a lot of time, effort, and dedication. This warning is not meant to scare you away, just to make sure you understand what you are getting into. We recommend MicroMouse teams consist of 4 or 5 people to make the workload manageable, with each person having a specific role (e.g. mechanical, electrical, software, etc.).</p> <p>It is usually a good idea to make your first MicroMouse simple. Remember, this is a club for college students, and the competitions we attend are not as competitive as the ones shown in the Veritasium video. Solving the maze, regardless of how fast you do it, will typically land you within the top 10 at most college-level competitions.</p> <p>However, if you are feeling adventurous and your team members have some more electrical experience (and abundant free time), designing a custom PCB may be the route for you. Be warned, this comes with its challenges and risks, as R&amp;D of PCBs can be very complicated and potentially quite expensive if you need to order more than one version.</p> <p>With all that said, this wiki contains information relevant to both routes, with specifics intermixed when necessary.</p>"},{"location":"micromouse/getting-started/#creating-a-proposal","title":"Creating a Proposal","text":"<p>Our club only has a limited budget, so we ask that your MicroMouse team create a \"proposal\" outlining your robot design before any parts are ordered.</p> <p>Create a repository on our GitHub organization and write your proposal in the repo's README.md file. See our Proposal Example.</p> <p>Your MicroMouse proposal should include:</p> <ul> <li>A list of all parts you plan to use, including links and prices.<ul> <li>Parts may only be purchased from vendors on the SA approved vendors list.</li> <li>Your team's budget is flexible, but you should aim to keep your total cost around $100.</li> <li>If you plan to use a part we already have in stock, include the part in your list but do not include a link or price.</li> </ul> </li> <li>An electrical schematic of your robot.<ul> <li>Must show how all components are connected together and powered.</li> <li>You can use KiCad, NI Multisim, or another schematic software to create this, or you can just draw it out by hand.</li> </ul> </li> <li>A Hardware Plan<ul> <li>Detailed explanation of how your hardware will work. This should demonstrate that you understand the electrical requirements of all the individual components and have a solid plan for how they will all interact with each other. Creating a CAD model of your robot is recommended.</li> </ul> </li> <li>A Software Plan<ul> <li>Detailed explanation of how your software will work. This should include the programming language(s) you will be using, any libraries, what IDE(s) you will be working with, your approach for testing your software, and how you will be using the inputs from your hardware to complete your task.</li> </ul> </li> <li>A list of team members and their responsibilities.<ul> <li>Each team member should include a one paragraph description of their responsibilities on the MicroMouse team.</li> </ul> </li> <li>A timeline for your project with milestones.<ul> <li>A list of important dates and what you plan to accomplish by each date.</li> </ul> </li> </ul>"},{"location":"micromouse/getting-started/#designing-your-micromouse","title":"Designing Your MicroMouse","text":""},{"location":"micromouse/getting-started/#dimensional-constraints","title":"Dimensional Constraints","text":"<p>The first thing to think about is how big your MicroMouse should be. Size will impact many future design decisions, such as which motors and sensors you use.</p> <p>Each cell of the maze is 18 cm square. Each wall of the maze is 1.2 cm wide, so there is 16.8 cm of free space in between the walls. Your MicroMouse should give at least a few centimeters of clearance on each side. </p> <p>If you plan for your MicroMouse to drive diagonally between cells, it will need a width smaller than 11.8 cm. You should give a healthy amount of clearance too, since driving diagonally is much more dangerous than driving normally. The constraints for diagonal-capable robots are very difficult to work with. Don\u2019t feel like you need to go diagonally \u2013 there are plenty of speedy MicroMouse robots that win competitions without being able to do so.</p> <p>The cells are 5 cm tall, but there is no height limit for your robot.</p>"},{"location":"micromouse/electrical/","title":"Electrical Tips","text":"<ul> <li> Wiring</li> <li> PCB Design</li> </ul>"},{"location":"micromouse/electrical/pcb-design/","title":"MicroMouse PCB Design Tips","text":"<p>Section coming soon... bug Peter Lilley about this if you need it now.</p>"},{"location":"micromouse/electrical/wiring/","title":"Wiring a MicroMouse","text":"<p>Section coming soon...</p>"},{"location":"micromouse/mechanical/","title":"Mechanical Tips","text":"<ul> <li> 3D Printing</li> </ul>"},{"location":"micromouse/mechanical/3d-printing/","title":"MicroMouse 3D Printing","text":"<p>Almost every modern MicroMouse robot has at least a few 3D printed parts. The robot's chassis is usually 3D printed, and many robots have 3D printed wheels and gears.</p> <p>We recommend using Onshape for CAD work, as it is free and personal use and makes collaboration with other team members easy. Our club uses Onshape for most CAD work.</p> <p>You may 3D print parts on campus in the DREAM lab at Bonner 118.</p> <p>TODO: More info on 3D printing best practices.</p>"},{"location":"micromouse/modules/","title":"MicroMouse Modules","text":"<ul> <li> Battery &amp; Power Distribution</li> <li> Motors &amp; Encoders</li> <li> Drivetrain</li> <li> Wall Sensors</li> <li> Microcontroller</li> <li> Buttons &amp; Switches</li> <li> LEDs &amp; Buzzers</li> <li> IMU</li> </ul>"},{"location":"micromouse/modules/battery-and-power-distribution/","title":"Battery and Power Distribution","text":"<p>Power distribution is a critical part of your MicroMouse design. The decisions you make here will dictate much of what your robot will look like as you move forward. </p>"},{"location":"micromouse/modules/battery-and-power-distribution/#picking-a-battery","title":"Picking a Battery","text":"<p>First you must select a battery to use. There are many different types of batteries, each with different strengths and weaknesses. Here is a list of some common battery chemistries that may be used for MicroMouse:</p>"},{"location":"micromouse/modules/battery-and-power-distribution/#lithium-batteries","title":"Lithium Batteries","text":"<p>Lithium batteries come in two flavors: Lithium-Ion (Li-Ion) and Lithium Polymer (LiPo).</p> <p>Lithium-Ion batteries use a liquid electrolyte and are usually rectangular or circular in shape. Li-Ion batteries have a high energy density and have long life spans.</p> <p>Lithium Polymer batteries use solid or gel-like polymer electrolyte, which allows them to be made in all different shapes and sizes. LiPo batteries have a lower energy density than Li-Ion batteries but often have faster discharge rates.</p> <p>Most MicroMouse robots use LiPo batteries.</p> Safety Warning <p>Lithium batteries can be very dangerous if used improperly and become a huge fire hazard if any of the following happens to them:</p> <ul> <li>Punctured/damaged</li> <li>Terminals shorted</li> <li>Charged too fast/incorrectly</li> </ul> <p>Lithium battery fires are self-contained, meaning that they do not require any external fuel to continue burning. This means that Lithium battery fires are extremely difficult to put out. A normal everyday fire extinguisher will not suffice, only a class D fire extinguisher will do the job. Lithium battery fires also produce toxic fumes.</p> <p>There are usually warning signs before a lithium battery catches fire. Some include swelling/bulging, leaking, making noises, or smelling weird (a \"sweet\" smell, or burning).</p> <p>If ever you experience a Lithium battery fire, evacuate the area immediately. Call campus PD at 716-645-2222 for the fastest response time.</p> <p>Li-Ion/LiPo batteries are made from either a single Li-Ion/LiPo cell, or multiple cells wired together in series. A single cell has a nominal voltage of 3.6 - 3.7 V, with a fully charged voltage of 4.2 V. It is important not to discharge a cell lower than 3 V; the lowest you go should be 3.3 V. Single-cell batteries can be charged easily using simple chargers (many are sold with one included). On the other hand, multi-cell batteries require advanced chargers that can evenly charge all cells at once.</p> <p>Many MicroMouse robots use a single-cell battery and regulate it down to 3.3V (see Regulating Battery Power). If you are planning to use components that require more than 3.3V (most motors do), you can either boost that voltage up, or use a dual-cell battery and regulate it down to 5 or 6 V.</p> <p>Li-Ion/LiPo batteries will have a capacity rating in mAh and a discharge rating in C. To determine how much current a battery can supply, use the following formula:</p> \\[ I_{max} = \\text{Capacity} \\times \\text{Discharge Rating} \\] <p>For example, a \\(500 \\text{ mAh}\\) battery with a \\(20 \\text{ C}\\) discharge rating can supply a maximum of \\(0.5 \\text{ A} \\times 20 = 10 \\text{ A}\\) of current.</p> <p>When designing your robot, make sure that all of your components combined will not draw more current than your battery can supply. If you exceed this limit, your battery may overheat and become damaged or even catch fire.</p>"},{"location":"micromouse/modules/battery-and-power-distribution/#nimh-batteries","title":"NiMH Batteries","text":"<p>Most rechargeable AA, AAA, 9V, etc. batteries will be Nickel-metal hydride (NiMH) batteries. These batteries are much safer than Li-Ion/LiPos, however they have lower capacities and lower discharge rates. If you decide to go this route, you will need to minimize the current draw from all your robot's components. If you are using weak motors and don\u2019t plan on going very fast, you might be able to make it work. These batteries are also large and somewhat heavy. Each NiMH AA battery has a nominal voltage of 1.2V, so you would need five wired in series to get to 6V. With good design, anything is possible, just be aware of the constraints.</p>"},{"location":"micromouse/modules/battery-and-power-distribution/#regulating-battery-power","title":"Regulating Battery Power","text":"<p>Unless you are using a battery pack with a built-in regulator, you must add a system of your own.</p> <p>You may wonder: why not just power components directly from the battery? This could be problematic because the output voltage from your battery will not be consistent. Some components (i.e. your MicroController) require a stable voltage to work properly, so random spikes in battery voltage could cause your robot to stop working.</p> <p>Regulating the battery voltage solves this issue by dropping or raising it to a consistent level. For example, a MicroMouse using a nominal 7 V battery might regulate its voltage down to 5 V to power its 5 V Arduino and sensors. Sometimes a MicroMouse will need multiple regulators if it is using components with different operating voltages.</p> <p>Note</p> <p>Almost all components on your robot will require a stable voltage (usually 5 V or 3.3 V) to work properly. However, motors are special. If you can, it is often a good idea to place them downstream of your regulator so that they get a consistent voltage. This is a must for advanced BLDC motors, but for brushed DC motors it is not as important. If your regulated voltage is significantly lower than your motor voltage or your motors draw too much current for your regulator, consider powering them directly from battery power instead (if the voltage is suitable). Note that as the battery drains, the motors will slow down relative to the battery's voltage. Your robot can compensate for this with well-tuned PID controllers.</p> <p>There are multiple ways to drop/raise your battery voltage to a stable level. Each method has its own advantages and disadvantages. The main two methods are Low-dropout (LDO) voltage regulators and switching regulators.</p>"},{"location":"micromouse/modules/battery-and-power-distribution/#low-dropout-ldo-voltage-regulators","title":"Low-Dropout (LDO) Voltage Regulators","text":"<p>LDOs are simple, plug-and-play components that will drop a voltage without issue. However, LDOs can be very inefficient under certain circumstances. LDO power dissipation is affected by the voltage drop and by the output current. Use the following formula to determine how much power will be lost using an LDO:</p> \\[ P=\\left(V_{in}-V_{out}\\right) \\times I_{out} \\] Example <p>Dropping 2V with an output current of 500 mA would result in 1W of power lost, primarily to heat. Not great.</p> <p>There are only really two reasons to justify using an LDO on a MicroMouse:</p> <ol> <li>Space is extremely limited</li> <li>You plan on drawing very little current, so the power loss is negligible</li> </ol> <p>We do not recommend using a LDO for your main voltage regulator. However, an LDO would be acceptable in situations where you need to drop the voltage a little bit to power a single sensor or something.</p> <p>For your main voltage regulator, consider using a switching regulator instead of an LDO.</p>"},{"location":"micromouse/modules/battery-and-power-distribution/#switching-regulators","title":"Switching Regulators","text":"<p>Switching regulators are complex systems consisting of many components. These types of regulators are often considerably more efficient than LDOs and are therefore recommended for MicroMouse, especially when dropping more than a few volts and drawing more than a few hundred milliamps of current. However, switching regulators take up more space, are more expensive, and may introduce electrical noise into the output.</p> <p>Designing a switching regulator circuit can be challenging; however, there are pre-designed boards available to buy that work well. Search for \"buck converter\" (for step-down regulators) or \"boost converter\" (for step-up regulators) to find options.</p> <p>If you plan to design your own switching regulator (i.e. for a custom PCB MicroMouse), consider checking out TI\u2019s WEBENCH Power Designer to generate an example circuit tuned specifically for your requirements. </p>"},{"location":"micromouse/modules/buttons-and-switches/","title":"Buttons and Switches","text":"<p>Every MicroMouse robot needs a way for its handler to interact with it in between runs at competitions. Your robot must have an easy way to start and stop a run, and it is also a good idea to provide a way to change its speed and search algorithm, and a way to reset the maze data in case of a crash.</p> <p>Tip</p> <p>You can reuse other sensors on your robot to act like buttons.</p> <p>For example, many MicroMouse robots use their navigation IR sensors to detect a hand wave in front of them, signaling that they should start a run. This is a good way to start the maze navigation, since you will not risk accidentally moving the robot while trying to press a button.</p> <p>Additionally, some robots use their wheels as dials to cycle through speed or algorithm options using their encoders. This works best if your robot has a screen or an LED array to provide feedback.</p> <p>Raspberry Pi Picos and some Arduinos come with a programmable built-in button, but you will almost always want to add more. </p> <p>Adding physical buttons or switches is relatively easy. There are 4 main types of electrical switches: SPST, SPDT, DPST, and DPDT. DPST and DPDT switches are essentially just two SPST or SPDT combined into one. Triple-Pole and greater switches also exist but are rare.</p> <p>See the diagrams for each type of switch:</p> <p> </p> <p>For Single-Pole Single-Throw (SPST) switches, connect A to VCC and connect B to your MCU. If your MCU has an internal pull-down resistor, enable it in code. Otherwise, add a pull-down resistor between B and GND. In this configuration, the pin will read low when the button is not pressed, and high when it is pressed. Alternatively, you can connect A to GND and add a pull-up resistor between B and VCC if you prefer that the pin reads high when the button is not pressed.</p> <p>Single-Pole Double-Throw (SPDT) switches are similar, but they do not require a pull-up or pull-down resistor. Simply connect A to VCC, B to GND, and C to your MCU. Check the switch's \"default\" position in the datasheet to determine whether the pin will read high or low when it is not pressed.</p> <p>Tip</p> <p>Some MCUs allow you to configure a pin to trigger an interrupt when it changes state. This interrupt can be used to call a function in your code whenever the button is pressed or released. If your MCU does not support this, you can still check the pin in a loop and wait for it to change state for the same effect.</p>"},{"location":"micromouse/modules/drivetrain/","title":"Drivetrain","text":""},{"location":"micromouse/modules/drivetrain/#wheels-and-axles","title":"Wheels and Axles","text":"<p>Wheels are simple. You can use big wheels or small wheels. The circumference of your wheel should be considered when selecting your motor to determine what RPM and Torque you need (see Selecting a Motor).</p> <p></p> <p>The most important thing to consider is how your wheel will attach to your drive axle/motor shaft. At the scale of MicroMouse, options are limited. </p>"},{"location":"micromouse/modules/drivetrain/#d-shafts","title":"D-Shafts","text":"<p>Many MicroMouse robots use D-shafts and a specialized wheel to fit it snugly. The popular gearmotor has a D-shaft.</p> <p>Tip</p> <p>Normal round shafts can be turned into D-shafts with a metal file and some determination!</p> <p>It will be challenging to find COTS wheels that will work perfectly with a D-shaft. Instead, we recommend 3D printing wheels instead and buying tires separately. There are many RC car tires on Amazon that will work.</p>"},{"location":"micromouse/modules/drivetrain/#using-bolts-as-axles","title":"Using Bolts as Axles","text":"<p>Some MicroMouse robots use bolts as axles. Simply slide a wheel onto a bolt and secure it to a bearing with a nut, preferably a nylon lock nut. </p>"},{"location":"micromouse/modules/drivetrain/#gears","title":"Gears","text":"<p>If you plan to use gears in your drivetrain, we recommend buying Acetal gears from a site like McMaster-Carr.</p> <p>3D printing gears is possible, but they will not be very precise and will wear down quickly.</p>"},{"location":"micromouse/modules/drivetrain/#example-drivetrain-configuration","title":"Example Drivetrain Configuration","text":"<p>The MicroMouse seen above uses gearmotor with a D-shafts to drive the front right and back left wheels. The center gears, front left wheel, and back right wheel use nylon M3 bolts as axles with M3 nylock nuts to secure them to the bearings. Gears are Acetal gears purchased from McMaster-Carr, and the wheels are 3D printed.</p> <p>This motor configuration is very uncommon. Normally, motors are placed back to back. However, this configuration allows for a smaller robot width to allow for diagonal driving.</p>"},{"location":"micromouse/modules/imu/","title":"IMU","text":"<p>An Inertial Measurement Unit (IMU) consists of a Gyroscope and an Accelerometer in one small package. An IMU can be used to measure your robot\u2019s angular velocities (roll, pitch, and yaw), and its linear accelerations (X, Y, and Z). Some MicroMouse robots do not have an IMU, since the essential information (yaw velocity, forward acceleration) can be derived from wheel encoder readings.  </p> <p>For most robots, this method of only using encoders works fine. However, high-speed robots will benefit from having an IMU because encoder readings can become inaccurate when tires slip. Adding a second measurement input to your robot\u2019s odometry and PID controllers can only improve its consistency.  </p> <p>Note</p> <p>Do not spend lots of money for a super accurate IMU. With proper filtering, most low-end IMUs will suffice. Remember, your robot\u2019s IMU just needs to be good enough to supplement your encoders. </p> <p>IMUs can also be useful for detecting crashes. Sudden spikes in pitch and roll velocities could indicate that the robot has flipped over. A sudden negative forward acceleration could indicate that the robot has crashed into a wall. </p>"},{"location":"micromouse/modules/leds-and-buzzers/","title":"LEDs and Buzzers","text":"<p>Often it is helpful to know what your MicroMouse is thinking while it is driving around. Unless your MicroMouse has wireless capabilities, LEDs and/or a Buzzer are must-haves.</p> <p>LEDs are nice because they look cool and can immediately let you know when something is happening. However, it is important not to add too many, since LEDs can draw a lot of current. Your power distribution system is going to limit how many you can add.</p> <p>Tip</p> <p>One handy trick you can do for debugging: with multiple nearby LEDs, you can display an error code in binary. With 5 LEDs, you can display 31 different error codes (\\(2^{5}-1\\)). With 6, 63 (\\(2^{6}-1\\)). </p> <p>Buzzers are another helpful addition to your robot for debugging.  Simple buzzers are controlled using a PWM signal with 50% duty cycle. Changing the frequency of the signal will change the audio frequency produced by the buzzer. For most low-quality buzzers, these frequencies will not directly correlate with each other, but you can spend the time to \"tune\" your buzzer by figuring out which PWM frequencies correspond to which notes. Once your buzzer is tuned, you can program your favorite songs into your firmware for your MicroMouse to play while it\u2019s driving around!</p> <p>These Piezo Buzzers from Adafruit work well for MicroMouse robots.</p>"},{"location":"micromouse/modules/microcontroller/","title":"Microcontroller","text":"<p>There are many, many microcontrollers that can be used for MicroMouse robots. Which one you select will usually come down to availability or personal preference. </p> <p>In general, you should not feel the need to get the fastest or most \"powerful\" MCU you can find, since your MicroMouse code is not likely to be very processor-intensive unless you plan to perform image processing or something. There are plenty of exceptional MicroMouse robots using just an Arduino Nano that have no problems with processing speed.</p>"},{"location":"micromouse/modules/microcontroller/#arduino","title":"Arduino","text":"<p>If this is your first MicroMouse, consider using an Arduino. Arduinos are easy to use and have tons of online documentation. You will be able to find code examples online for almost any hardware component you need to interface with. Arduinos also come in all different shapes and sizes and with different features, so you can choose the model that best suits your robot's needs. </p> <p>Our club has a ton of Arduinos in stock, so you can get started experimenting with them in no time.</p>"},{"location":"micromouse/modules/microcontroller/#raspberry-pi-pico","title":"Raspberry Pi Pico","text":"<p>Raspberry Pi Picos are small boards based on the RP2040 MCU. Picos are close in size to Arduino Nanos, but are more powerful and featureful. One special feature for Picos is that they officially support MicroPython, a subset of Python 3 designed to run efficiently on microcontrollers. Alternatively, Picos can also be programmed in C or C++ like Arduinos.  The RP2040 has two processing cores, which can be used however you want for parallelizing your robot program. Pico W models come with Wi-Fi support, which may come in handy when debugging (not allowed at competitions though).</p> <p>Our club also has many Raspberry Pi Picos in stock.</p>"},{"location":"micromouse/modules/microcontroller/#stm32","title":"STM32","text":"<p>If you want something more advanced, consider using an STM32. STM32s are a great choice of MCU if you are designing your own PCB, since you can choose the variety that best suits your robot. You can find STM32s that are low-power, ones that have lots of IO, or ones with wireless capabilities. </p> <p>You can also find premade Nucleo or Blue Pill boards for sale that use STM32s if you don\u2019t want to design something custom. </p> <p>STM32s are notoriously much more difficult to program compared to an Arduino, but ST\u2019s CubeIDE/CubeMX are helpful tools to get started.</p>"},{"location":"micromouse/modules/microcontroller/#esp32","title":"ESP32","text":"<p>We have not had anybody from this club use an ESP32 chip before; however, they are a perfectly viable MCU option for MicroMouse robots. Many ESP32 chips come with Wi-Fi or Bluetooth capabilities that may be handy for debugging.</p>"},{"location":"micromouse/modules/motors-and-encoders/","title":"Motors and Encoders","text":""},{"location":"micromouse/modules/motors-and-encoders/#selecting-a-motor","title":"Selecting a Motor","text":"<p>There are several factors to consider when selecting a motor:</p> <ol> <li>Motor Type</li> <li>Voltage + Current Draw</li> <li>RPM + Torque</li> <li>Encoder Compatibility</li> </ol>"},{"location":"micromouse/modules/motors-and-encoders/#motor-type","title":"Motor Type","text":"<p>There are two main types of DC motors: brushed and brushless. Without going into the specifics of how they work, here's a brief description of both kinds:</p> <ol> <li> <p>Brushed Motors</p> <ul> <li>Cheap and easy to find</li> <li>Easily controlled by varying the voltage supplied to them. An H-bridge can be used for this</li> <li>Do not include any sensors to determine their position or speed \u2014 an external sensor (like an encoder) is required</li> </ul> </li> <li> <p>Brushless Motors (BLDC)</p> <ul> <li>Expensive</li> <li>Require a specialized controller (ESC) to control them</li> <li>Typically include an internal encoder that can be used to determine their position and speed</li> </ul> </li> </ol> <p>For MicroMouse, we recommend using brushed DC motors \u2014 you really do not need the extra complexity of brushless motors. For the most part, this wiki will focus on brushed DC motors. If you choose to use a BLDC motor, I assume you know what you are doing.</p>"},{"location":"micromouse/modules/motors-and-encoders/#motor-voltage-current-draw","title":"Motor Voltage + Current Draw","text":"<p>You should have already figured out which battery you are using and how your motors will be powered (see Battery &amp; Power Distribution).  </p> <p>The voltage listed in the description of a motor is typically its max voltage. For normal brushed DC motors, it is fine to run them slightly below their listed voltages (they will just be slower).  If you are using a BLDC, be careful with how you power it because they usually have strict requirements. Make sure that you follow its instructions well. </p> <p>Another essential consideration is the current draw of your motors. In the datasheet for your motor, look for a value named \"stall current\". This is the maximum current that the motor will draw (when it is stalled, producing its maximum torque). Make sure your robot's power distribution system can handle this (while powering other components too!). If you are very limited and cannot always guarantee that your power distribution system can supply enough current, consider adding a fuse to protect your motors and other components from damage in case of a stall.</p>"},{"location":"micromouse/modules/motors-and-encoders/#rpm-torque","title":"RPM + Torque","text":"<p>To determine the RPM you need from your motors, first determine the maximum speed you want your MicroMouse to travel at. For most robots, 1 m/s is a good upper limit. Some advanced MicroMouse robots may go upwards of 3 m/s.</p> <p>Next, determine the wheel diameter you will be using.</p> <p>With these values, you can calculate the RPM you need from your motors using the following formula:</p> \\[ \\text{RPM} = 60 \\times \\frac{\\text{velocity}}{\\pi \\times \\text{wheel diameter}} \\] <p>If you are planning to gear down your motors, make sure to account for that as well.</p> <p>Note that the RPM listed in a motor's description is usually its maximum free-spinning RPM. When under load (moving your robot), its RPM will be lower. When selecting a motor, choose one that is rated for a higher RPM than you need, maybe 20-30% higher.</p> Example <p>$ \\text{wheel diameter} = 5 \\text{ cm}$</p> <p>$ \\text{maximum velocity} = 100 \\text{ cm} /\\text{s}$</p> <p>$ \\text{motor speed} = 60 \\times \\frac{100}{\\pi \\times 5} = 382 $ RPM</p> <p>In this case, you will need a motor that can provide at least 382 RPM under load. Using a motor with a free-spinning speed of 500-600 RPM might be a good choice.</p>"},{"location":"micromouse/modules/motors-and-encoders/#encoders","title":"Encoders","text":"<p>Encoders are essential for precise control of your robot. In certain cases, they can be omitted in lieu of a super accurate IMU or an amazing vision system, but chances are you do not want to go down that road.</p> <p>Encoders provide information about the velocity of your motors and distance traveled. Without them, it is very difficult to control your robot's speed and position accurately.</p> <p>There are two main types of encoders: optical and hall effect.</p>"},{"location":"micromouse/modules/motors-and-encoders/#optical-encoders","title":"Optical Encoders","text":"<p>Optical encoders work by spinning a disk with slits in it, then shining a light through the disk and checking whether the light passes through or not. As it rotates, your MCU can count pulses from the encoder to determine how far the motor has turned. See Using Quadrature/Incremental Encoders.</p>"},{"location":"micromouse/modules/motors-and-encoders/#hall-effect-encoders","title":"Hall Effect Encoders","text":"<p>Hall effect encoders work by spinning a magnet with radially alternating poles past a hall effect sensor.  The sensor detects the change in magnetic field as the magnet passes by and sends a pulse to your MCU. As with optical encoders, you can count these pulses to determine how far the motor has turned. See Using Quadrature/Incremental Encoders.</p> <p>Hall effect encoders are usually smaller than optical encoders, making them a good choice for MicroMouse robots. They are also generally more reliable. However, the precision of hall effect encoders is limited by the number of radial poles on the magnet.</p>"},{"location":"micromouse/modules/motors-and-encoders/#encoder-precision","title":"Encoder Precision","text":"<p>Typically, the greatest number of radial poles that you can find on a magnet small enough for MicroMouse is 6. Optical encoder disks may have double that number of slits. A good way to gauge encoder precision is by calculating the distance that the robot travels per encoder pulse.</p> \\[ \\text{distance per pulse} = \\frac{1}{\\text{pulses per revolution}} \\times \\text{wheel diameter} \\times \\pi \\] Example <p>$ \\text{encoder pulses per revolution} = 6$</p> <p>$ \\text{wheel diameter} = 5 \\text{ cm}$</p> <p>$ \\text{distance per pulse} = \\frac{1}{6} \\times 5 \\times \\pi = 2.62 \\text{ cm}$</p> <p>Remember that MicroMouse robots are very small \u2014 the size of a maze cell is only 18 cm. Using an encoder attached directly to your robot's wheels with only 6 pulses per revolution will not provide enough precision for most robots, especially if the robot is using large wheels. To improve the precision, consider gearing your drivetrain in such a way that your robot's wheels rotate slower than your encoders. These gearmotors described later make this easy.</p> Revised Example with Gear Ratio <p>$ \\text{wheel diameter} = 5 \\text{ cm}$</p> <p>$ \\text{gear ratio} = 40:1$</p> <p>$ \\text{encoder pulses per revolution} = 6 \\times 40 = 240$</p> <p>$ \\text{distance per pulse} = \\frac{1}{240} \\times 5 \\times \\pi = 0.07 \\text{ cm}$</p> <p>Compared to the previous example, this drivetrain is considerably more precise with a distance per pulse less than 1 mm. Excellent.</p> <p></p>"},{"location":"micromouse/modules/motors-and-encoders/#using-quadratureincremental-encoders","title":"Using Quadrature/Incremental Encoders","text":"<p>Most encoders are \"quadrature\" or \"incremental\" encoders which have two output channels (A and B). If your encoder instead uses an I2C or SPI interface, refer to the manufacturer's documentation for how to use it.</p> <p>For hall effect encoders, channels A and B typically correspond to two hall sensors placed 90 degrees out of phase with each other. These signals will tell you whether the sensor is seeing a north or south pole of the magnet. As the magnet spins, your MCU can count the pulses of these signals to determine how far the motor has turned. To determine the direction of rotation, check which channel is leading the other, like so:</p> <p> </p> <p>On your MCU, you can use external interrupts to trigger when the channels change state. However, your encoders will likely be spinning very fast \u2014 potentially faster than your MCU can keep up with. Instead, (if your MCU supports it) consider using hardware timers to count the encoder pulses for you. Then your code just need to read the timer value whenever it needs encoder information. STM32s are awesome at this.</p>"},{"location":"micromouse/modules/motors-and-encoders/#good-micromouse-motors-and-encoders","title":"Good MicroMouse Motors and Encoders","text":""},{"location":"micromouse/modules/motors-and-encoders/#gearmotor-w-extended-back-shaft-and-hall-effect-encoder","title":"Gearmotor w/ Extended Back Shaft and Hall Effect Encoder","text":"<p>Many MicroMouse robots use this geared brushed DC motor + Hall Effect encoder combo:</p> <p></p> <p>These motors have a few benefits:</p> <ol> <li>Small size</li> <li>Cheap</li> <li>Available with a variety of gear ratios \u2014 good for fast or slow robots</li> <li>D Shaft, easy to attach wheels</li> <li>Easy encoder integration (before gearing, so high precision)</li> <li>Relatively easy to mount (you must 3D print a part to clamp the geared area)</li> <li>Available in many different voltages (3.3V, 6V, 12V)</li> </ol> <p>If you choose this route, you might be able to buy the motor with an encoder pre-attached, but most likely you will need to buy them separately and solder them together yourself.</p> <p>For the motor, make sure you buy one with an \"extended back shaft\" \u2014 this is essential for mounting the encoder. 50:1 is a good gear ratio for most MicroMouse robots. If you have a need for speed, consider 30:1 or 20:1.</p> <p>For the encoder, you can find \"regular\" ones which stick out the flat side of the motor (see the image above), or \"sideways\" ones that go the other way. Choose whichever one better fits your robot.</p> <p>Some encoders come with JST connectors. These connectors can be handy; however, they are not meant for frequent plugging and unplugging because the pins bend very easily. If you want to aviod this headache, buy ones that you can solder wires to yourself.</p> <p>Links: </p> <ul> <li>Digikey: 50:1 Motor, Regular Encoder (2-pack) </li> <li>Pimoroni: Motor, Regular Encoder (2-pack), Sideways Encoder (2-pack) </li> </ul>"},{"location":"micromouse/modules/motors-and-encoders/#faulhaber-1717sr-series-motor","title":"Faulhaber 1717SR Series Motor","text":"<p>Many top MicroMouse robots use these Faulhaber 1717SR series motors (1717T003SR for 3V or 1717T006SR for 6V) combined with an IE2-512 encoder. These motors and encoders are very small and considerably powerful; however, they are quite expensive ($200+ each).  </p> <p>Links: </p> <ul> <li>1717T003SR </li> <li>IE2-512</li> </ul>"},{"location":"micromouse/modules/motors-and-encoders/#controlling-brushed-dc-motors","title":"Controlling Brushed DC Motors","text":"<p>To adjust the speed of a brushed DC motor, you must adjust the voltage supplied to it (e.g. for a 5 V motor, 5 V is full speed, 0 V is stopped, and 2.5 V is half speed). To change a motor's direction, flip its polarity.</p> <p> </p> <p>Normally it is difficult to produce a variable voltage to control motors, so most applications use PWM (Pulse Width Modulation) to simulate a lower voltage by switching from high voltage to low voltage at a high frequency. Depending on the duty cycle of the PWM signal (percent time high during one cycle), the resulting average voltage will change.</p> <p>Almost all modern MCUs (Arduino, STM32, etc.) can output a PWM signal from at least a few of its pins. However, these pins cannot supply enough current to directly power a motor. H-Bridge motor controllers solve this problem by providing an easy way to use an alternate power source to power motors.  </p> <p>H-Bridge motor controllers typically come in one of two (sometimes both \u2013 you choose) control methods: IN/IN or PHASE/ENABLE (I\u2019m using TI\u2019s terminology here, might be described differently in other places). For IN/IN, the H-Bridge has two PWM inputs, one for forward speed and the other for reverse speed. PHASE/ENABLE on the other hand has two inputs: PHASE controls the direction of the output, and ENABLE controls whether it is on/off, which you can control using PWM to adjust the speed of the motor.</p> <p>MicroMouse robots typically have two motors, so instead of getting two H-Bridge components for your robot, look for a single \"Dual H-Bridge\" component that integrates two H-Bridges into one small package. </p> Joke: Why was the PWM wire always calm and collected? <p>Because it knew how to keep its pulse under control!</p>"},{"location":"micromouse/modules/wall-sensors/","title":"Wall Sensors","text":"<p>Every MicroMouse must have sensors to detect the maze walls. You can get creative with this, as there are many perfectly reasonable solutions. </p> <p>Note</p> <p>For the most part, everything described in this section will focus on robots that use simple distance sensors to detect nearby walls while navigating through the maze. If you plan to use a camera or some other wacky method instead, I assume you know what you are doing. </p> <p>The sensor choices you make here will impact how you navigate through the maze, see Navigation for details about that.</p> <p>Your MicroMouse should be able to detect at least the wall in front of it, and the walls to the left- and right-hand sides (unless you want to only use the front sensor and spin around in every cell; I don\u2019t recommend it, but I won\u2019t stop you).</p> <p>When selecting sensors, determine whether you need a distance reading or just a binary 1 or 0 indicating whether a wall is present. Either option will work, but distance sensors will allow your robot navigate better.</p> <p>Below is a description of some common sensor types used in MicroMouse robots. Other types may also work.</p>"},{"location":"micromouse/modules/wall-sensors/#ir-sensors","title":"IR Sensors","text":"<p>IR sensors are commonly used by MicroMouse robots because they are small and can provide a relatively consistent distance reading. You can also use them digitally to simply check the presence of a wall. IR sensors have two parts: an emitter and a receiver. The emitter sends out a beam of infrared light. When a wall is present that light bounces off the wall and can be detected by the receiver.</p> <p>IR sensors can be complicated to get set up. You might be able to find a part that contains both the emitter and the receiver, but most likely you will need to source your own IR emitter and phototransistor separately. It is important to buy parts that are compatible with each other \u2013 the wavelength of the emitter should fall within the detectable range of the phototransistor. Ideally, the detectable range of your phototransistor should be small to avoid it from being affected by ambient light. </p> <p>Wiring the emitters is straightforward, just connect them to VCC and GND, making sure to not give them more voltage than they can handle. While this alone will work, it is also usually a good idea to add a simple transistor controllable from your robot's MCU to turn the emitters on/off. See the schematic below for an example of how to do this. Being able to turn off emitters is beneficial for two reasons. First, it saves battery life and reduces your current draw. Each emitter may draw 100mA of current, so only enabling one at a time will reduce the strain on your power supply. Second, enabling all four sensors at once will likely produce bad readings from your phototransistors, since light from other emitters may be picked up by the wrong receivers. In code, you should loop through each sensor and enable only one emitter at a time, then take the reading from its associated phototransistor. Once finished, turn off the emitter and then move on to the next one in the loop. </p> <p></p> <p>Wiring the phototransistors can be more complicated. Phototransistors essentially act as a resistor that varies resistance based on how much IR light it detects. With this, you can create a Voltage Divider to produce a voltage that can be read by your MCU. See the schematic below for an example. Note that this output is an analog signal, which is different from the typical digital signals that most sensors produce. Some MCUs may have a built-in ADC (analog to digital converter) that can operate on a few input pins (most STM32 and ESP32 chips have one). Some Arduino boards do not have an ADC, so you\u2019ll need a separate ADC component that will convert the signals from your sensors to a PWM signal or provide an I2C interface. If you choose not to use an ADC, you can treat the output of your phototransistor circuit as a digital (1/0) signal to check for the presence of a wall with no distance information. You will need to tune your voltage divider based on the trigger voltage of your MCU\u2019s pins.</p> <p></p> <p>Readings from IR phototransistors are not trivial to deal with for several reasons. To start, readings do not increase linearly with distance, instead they follow the inverse square law (\\(1/d^2\\)). Next, IR sensors may produce different readings in different environments or with different wall materials. Readings also may vary slightly from sensor to sensor. For these reasons, it is important to \"calibrate\" your sensors before traversing the maze. Your robot can perform a calibration on your left and right sensors at startup if it is able to see both side walls of the current cell. </p> <p>A popular emitter/phototransistor combo used by many MicroMouse robots is the SFH4545 + TEFT 4300</p>"},{"location":"micromouse/modules/wall-sensors/#time-of-flight-sensors","title":"Time-of-Flight Sensors","text":"<p>Time of Flight sensors are advanced components that can provide your robot with very precise distance measurements. ToF sensors work by emitting a laser beam and then determining the distance to nearby objects based on the time it takes to bounce back. ToF sensors are normally more expensive than other sensors and usually draw more current. However, ToF sensors are the best option if your MicroMouse needs to look very far in front or requires very reliable and consistent readings. </p> <p>ToF sensors are usually very easy to use. You can buy a board from Adafruit or design your own circuit following the instructions from the ToF sensor's datasheet. Most ToF sensors provide an I2C interface, some may be SPI. Conversion to physical units (mm) is done on-device, making it easy to get readings. You do not need to do any sort of \"calibration\" like IR sensors \u2013 these sensors are calibrated at the factory and will not be affected too much by ambient light. </p>"},{"location":"micromouse/modules/wall-sensors/#ultrasonic-sensors","title":"Ultrasonic Sensors","text":"<p>Ultrasonic sensors are a good sensor choice for simple MicroMouse robots. Ultrasonic sensors can be very bulky, but they will provide consistent distance readings and are easy to wire and use. Ultrasonic sensors typically output a low frequency PWM signal that can be easily read by your MCU. These are a good option for Arduino-based robots.</p>"},{"location":"micromouse/software/","title":"Software","text":"<ul> <li> Programming Language</li> <li> Code Structure &amp; Organization</li> <li> Maze Solving Algorithms</li> <li> Robot Control &amp; Navigation</li> <li> Offline Simulation</li> <li> Unit Testing</li> </ul>"},{"location":"micromouse/software/code-organization/","title":"Code Structure &amp; Organization","text":"<p>Programming a MicroMouse is no easy task. It is essential that you stay organized and start coding your MicroMouse the right way before you run into problems. </p> <p>Code organization is important. Writing all your code in one file is not going to work well in the long term. Splitting your program into different subsystems is essential for you and others to follow and understand what your code is doing. In an OO language like C++, each subsystem should be its own class: \"Drive\", \"Vision\", \"Navigation\", etc. In non-OO languages like C, simply put these subsystem implementations into their own files. </p> <p>You will undoubtedly need to write drivers for your specific hardware components on your robot. The code for these should be abstracted away into their own classes/files and should not be placed within your subsystem code. This will make your code easier to follow and save you from having to refactor an entire subsystem if you decide to switch sensor types in the future. It will also make it easier to create multiple hardware implementations \u2013 good for desktop simulation or for running your code on a different robot. </p> <p>Depending on your MCU, your project structure may vary. For many MCUs (Arduinos), we recommend using PlatformIO to simplify your build system and give your project some organization. PlatformIO also provides a simple way to write Unit Tests. Do not plan on writing your entire MicroMouse code in the Arduino IDE \u2013 it was not made for doing this. </p> <p>For STM32, you should use the STM32 CubeIDE or CubeMX to set up your project.</p> <p>If you would like to get more advanced and design your own build system, consider using CMake to build your MicroMouse code. See the firmware for our PCB mouse for inspiration.</p>"},{"location":"micromouse/software/maze-solving-algorithms/","title":"Maze Solving Algorithms","text":"<p>There exist many different maze solving strategies used by MicroMouse robots, but no established \"best\". The algorithm which you choose can be as simple or as complex as you want, it's up to you. In this section, I will describe some good strategies and common practices, but feel free to experiment as you wish. </p> <p>Note</p> <p>Do not concern yourself with optimizing your algorithm until your MicroMouse can reliably navigate the maze. Simple algorithms will go a long way. We recommend that everybody implements FloodFill first. </p> <p>At most competitions, the time of your robot's initial \"search run\" does not matter because only the fastest run will count. However, some competitions (notably APEC) incorporate a \"search penalty\" to your final score, rewarding robots that have fast initial runs. For this reason, it is usually a good idea to search efficiently on your first run to the goal. Then once your robot reaches the goal, it can take as much time as it needs to return back to the start. </p> <p>Most MicroMouse robots use the FloodFill search algorithm during their search run because of its efficiency and its simplicity. However, FloodFill search will not guarantee that your robot reveals the shortest path (distance) to the goal on its first run. Therefore, your robot must use its \"travel back to the start time\" to search more of the maze. There are many options for how to do this: </p> <ol> <li>Use FloodFill to search back to the start. After returning to the start, your robot will have revealed a large portion of the maze, and more likely than not, has revealed the shortest path to the goal. If you want to be absolutely sure that your robot has revealed the shortest path, you can run FloodFill again from the start to the goal (or from the cell directly outside the start cell to the goal, if you need to save a run).</li> <li>Use BFS to search for the shortest path back to the start. BFS is guaranteed to find the shortest path, however it is not a very efficient algorithm because it involves lots of backtracking. Since your robot has already revealed parts of the maze on the way to the goal, you may be able to optimize BFS slightly to make it faster.</li> <li>Use DFS or similar algorithm to explore the entire maze. Once your robot has discovered every route to the goal, it can then compute the path to take during speed runs using factors other than distance. Robots that can drive diagonally or ones that can speed up very fast during straightaways may be able to choose faster paths this way. </li> </ol>"},{"location":"micromouse/software/maze-solving-algorithms/#floodfill","title":"FloodFill","text":"<p>FloodFill is a simple search algorithm used to find the shortest path to the goal in a maze. Given a grid of cells, FloodFill will output a grid of values which represent how far away each cell is from the goal. Navigating using FloodFill is simple: run the FloodFill algorithm with your current knowledge of the maze, and then drive your robot in the direction of the smallest value in the grid.</p> <p>Below is some pseudocode for Floodfill:</p> <pre><code>FloodFill(endpoints) \n  V = new Int[MAZE_WIDTH_CELLS][MAZE_LENGTH_CELLS]\n  V.fill(MAX_CELL_VALUE) \n\n  Q = new Queue&lt;Cell&gt; \n  Q.add(endpoints) \n\n  While (Q is not empty)\n    cell = Q.pop() \n    newValue = V[cell.x][cell.y] + 1 \n    Foreach (dir in { NORTH, EAST, SOUTH, WEST }) \n      If (cell.hasExit(dir))\n        nextCell = cell.neighbor(dir) \n        If (V[nextCell.x][nextCell.y] &gt; newValue) \n          V[nextCell.x][nextCell.y] = newValue \n          Q.push(nextCell) \n        End \n      End \n    End \n  End \n\n  return V \nEnd \n</code></pre>"},{"location":"micromouse/software/maze-solving-algorithms/#breadth-first-search","title":"Breadth First Search","text":"<p>See the BFS Wikipedia Article for implementation details.</p>"},{"location":"micromouse/software/maze-solving-algorithms/#depth-first-search","title":"Depth First Search","text":"<p>See the DFS Wikipedia Article for implementation details.</p>"},{"location":"micromouse/software/maze-solving-algorithms/#algorithm-simulation","title":"Algorithm Simulation","text":"<p>Our MicroMouse Simulator program lets you test the efficiency of different algorithms quickly on randomly generated mazes before you implement and test them on your actual robot. There are already a few popular algorithms implemented in the simulator. If you want to add your own algorithm, simply create a new class inherited from <code>Solver</code> and copy how the other solver classes are added. </p> <p>Alternatively, you could also check out mms, another simulator made by a former UB IEEE club member.</p>"},{"location":"micromouse/software/offline-simulation/","title":"Offline Simulation with ROS2","text":"<p>Testing every feature on your physical MicroMouse can be difficult and tedious, especially during the early stages of development when there are lots of bugs in your code. For this reason, we've experimented with running MicroMouse robot code natively on desktop and simulating the MicroMouse in a 3D engine. This speeds up the development process greatly since you can set breakpoints while the robot is driving and watch variables in real time \u2013 things not possible when running on a physical robot.</p> <p>To make this happen, you will need to abstract away all your code controlling the robot's hardware. You must configure your build system to have an option to build for robot or desktop. If robot, your build system must enable code controlling your robot's hardware. If desktop, it must enable code controlling the simulation.</p> <p>Your robot program needs a way to communicate with whatever 3D simulation application you plan to use. We've found that ROS2 is awesome for this, even though it sometimes can be painful to install. With ROS2, you can publish variables to \"topics\" that can be subscribed to by other processes. Some topics your robot program may want to publish would be <code>drive/linear_velocity</code> and <code>drive/angular_velocity</code>, and some topics your robot program may want to subscribe to would be <code>vision/ir_sensor_readings</code> and <code>buttons/1</code>. Your simulator program would then subscribe/publish to the topics used by your robot program.</p> <p>For your 3D simulator, you have many options. In the field of robotics research, Gazebo is often used for this kind of thing because it integrates with ROS2 well. However, Gazebo is not very well documented and can be very difficult to use. Instead, Game engines are easier to learn and can work just as well. We recommend using one that has native C++ support, since it will make your life easier integrating ROS2. For our recent PCB mouse, we used the Godot Engine with its GDExtension feature to use our C++ code. In your simulator, you should add a way to easily create mazes and save/load them from files. If you would like to see our Godot-based simulator, check it out here.</p>"},{"location":"micromouse/software/programming-language/","title":"Programming Language","text":"<p>Most MicroMouse robots are programmed in C or C++ because those are the most widely supported languages by MCUs. However, any other language that can be compiled to your MCU\u2019s architecture can also work as long as you have a hardware API to control peripherals. </p> <p>Your MCU\u2019s manufacturer will almost certainly provide a C API to control GPIO pins and other features of the MCU. C++ is essentially a superset of C, so it can call most C APIs without issue. Other languages may have an FFI that you can use to call the C API, or there might exist a community-supported port of the API (e.g. stm32-rs for Rust on STM32 boards). </p> <p>Some hardware might officially support languages other than C and C++ out of the box, but this is rare. One example of this is the Raspberry Pi Pico which supports MicroPython.</p>"},{"location":"micromouse/software/robot-control-and-navigation/","title":"Robot Control &amp; Navigation","text":"<p>Maze navigation is probably the most complicated part of the MicroMouse program since it takes a lot of testing and fine-tuning.  </p> <p>\"Navigation\" refers to the process of taking readings from sensors (wall sensors, motor encoders, IMU, etc.), then determining where the MicroMouse is in the maze and how to move. This process can be deceptively hard \u2013 just driving in a straight line for more than a few inches can be a considerabe challenge. </p>"},{"location":"micromouse/software/robot-control-and-navigation/#pid-control","title":"PID Control","text":"<p>Note</p> <p>While PID Controllers may have other applications on your robot besides navigation, I decided to put this section here because it is most commonly used for navigation tasks.</p> <p>Wikipedia does a good job of explaining PID controllers and how they work:</p> <p>Wikipedia</p> <p>A proportional\u2013integral\u2013derivative controller (PID controller or three-term controller) is a feedback-based control loop mechanism commonly used to manage machines and processes that require continuous control and automatic adjustment. It is typically used in industrial control systems and various other applications where constant control through modulation is necessary without human intervention. The PID controller automatically compares the desired target value (setpoint or SP) with the actual value of the system (process variable or PV). The difference between these two values is called the error value, denoted as \\(e(t)\\).</p> <p>It then applies corrective actions automatically to bring the PV to the same value as the SP using three methods: The proportional (P) component responds to the current error value by producing an output that is directly proportional to the magnitude of the error. This provides immediate correction based on how far the system is from the desired setpoint. The integral (I) component, in turn, considers the cumulative sum of past errors to address any residual steady-state errors that persist over time, eliminating lingering discrepancies. Lastly, the derivative (D) component predicts future error by assessing the rate of change of the error, which helps to mitigate overshoot and enhance system stability, particularly when the system undergoes rapid changes. The PID output signal can directly control actuators through voltage, current, or other modulation methods, depending on the application. </p> Simple P Controller Example <p>One application for a PID controller is to make a motor spin to a specific position. For this example, you can control a motor with a percent output (0 for stopped, 1.0 for full speed forward), and you have an encoder that will provide the position of the motor. </p> <p>Your target position is \\(60\\) degrees. This is your setpoint (SP). </p> <p>Your motor's current position is \\(0\\) degrees. This is your process variable (PV). </p> <p>Your error \\(e(t) = \\text{SP} \u2013 \\text{PV} = 60\\) degrees. </p> <p>Feeding this error into a simple Proportional (P) controller with \\(K_p = 0.01\\) will give you a motor output of \\(60 \\times 0.01 = 0.6\\). </p> <p>A short amount of time later, check the new position and re-run the controller. The new position is \\(20\\) degrees, so your error is now \\(40\\). Your motor's new output is \\(40 \\times 0.01 = 0.4\\). Notice how the motor is slowing down as it approaches the setpoint.</p> <p>Continue this process and eventually the setpoint will be reached. </p> <p>Some applications for PID controllers on MicroMouse robots include:</p> <ul> <li>To control each drive motor's velocity or position (using Encoder readings)</li> <li>To control the robot's angular velocity when turning (using IMU and/or Encoder readings)</li> <li>To center the robot in between walls (using wall sensor readings)</li> </ul>"},{"location":"micromouse/software/robot-control-and-navigation/#tuning-pid-controllers","title":"Tuning PID Controllers","text":"<p>Tuning PID controllers is the process of adjusting the P, I, and D values to get the desired behavior for your system.</p> <p>WPILib Docs</p> <p>These steps apply to position PID controllers. Velocity PID controllers typically don\u2019t need \\(K_d\\).</p> <ol> <li>Set \\(K_p\\), \\(K_i\\), and \\(K_d\\) to zero.</li> <li>Increase \\(K_p\\) until the output starts to oscillate around the setpoint.</li> <li>Increase \\(K_d\\) as much as possible without introducing jittering in the system response.</li> </ol> <p>Plot the position setpoint, velocity setpoint, measured position, and measured velocity. The velocity setpoint can be obtained via numerical differentiation of the position setpoint (i.e. \\(v_{desired,k}=\\frac{r_k-r_{k-1}}{\\Delta t}\\)). Increase \\(K_p\\) until the position tracks well, then increase \\(K_d\\) until the velocity tracks well.</p> <p>If the controller settles at an output above or below the setpoint, one can increase \\(K_i\\) such that the controller reaches the setpoint in a reasonable amount of time. However, a steady-state feedforward is strongly preferred over integral control (especially for PID control).</p> <p>Important</p> <p>Adding an integral gain to the controller is an incorrect way to eliminate steady-state error. A better approach would be to tune it with an integrator added to the plant, but this requires a model. Since we are doing output-based rather than model-based control, our only option is to add an integrator to the controller.</p> <p>Beware that if \\(K_i\\) is too large, integral windup can occur. Following a large change in setpoint, the integral term can accumulate an error larger than the maximal control input. As a result, the system overshoots and continues to increase until this accumulated error is unwound.</p>"},{"location":"micromouse/software/robot-control-and-navigation/#detecting-walls-and-staying-centered-in-the-cell","title":"Detecting Walls and Staying Centered in the Cell","text":"<p>Here are a few resources that may be helpful:</p> <ul> <li>Peter Harrison - \"Wall and Line Tracking for MicroMouse and Linefollowers\" Presentation</li> <li>Green - Calibration Strategy Tutorial</li> </ul>"},{"location":"micromouse/software/robot-control-and-navigation/#navigation-styles","title":"Navigation Styles","text":"<p>You will see two distinct styles of navigation done by MicroMouse robots: \"start-and-stop\" movement and \"fluid\" movement.</p> <p>As you might expect, the easiest way to navigate the maze is to move forward one cell, stop, take measurements, then decide where to move next. This is a good starting point for most MicroMouse robots. This can still be complicated because you need error correction based on your wall sensor readings to prevent small errors from accumulating. Refer to the previous section on PID control for details about that.</p> <p>Once you have established that your robot is capable of navigating the maze using the start-and-stop approach, consider implementing a navigation system to drive smoothly through the maze, making decisions while in motion. Despite how it may look, this approach is not much different than the previous one. The process is essentially the same except now there is no stopping. The tricky part is determining where to take readings from your sensors and when to start turning.</p>"},{"location":"micromouse/software/robot-control-and-navigation/#navigating-fast","title":"Navigating Fast","text":"<p>After navigating the maze and determining the fastest path to the goal, your MicroMouse can optimize its movements to travel faster because now it knows exactly where to go.</p> <p>A few things to do:</p> <ul> <li>Identify long straightaways in your desired path and calculate how much your robot should speed up during those sections.</li> <li>Determine how fast your robot can safely turn without crashing. You should increase your robot's turning radius to allow it to turn faster.</li> <li>Make sure that your robot can effectively center itself in the cell using its wall sensors, see the previous section for details. You will need a well-tuned system to travel fast without crashing.</li> <li>Use your robot's wall sensors to determine where it is based on presence of walls. When your sensors detect a wall or the absence of a wall, your robot can use the maze information it has previously gathered to help it determine how far it has traveled. This is good to supplement readings from your wheel encoders and other sensors.</li> </ul>"},{"location":"micromouse/software/robot-control-and-navigation/#driving-diagonally","title":"Driving Diagonally","text":"<p>Check out this awesome presentation by Derek Hall about driving diagonally:</p>"},{"location":"micromouse/software/unit-testing/","title":"Unit Testing","text":"<p>TODO: Write this section</p>"},{"location":"workshops/","title":"Workshops","text":"<ul> <li>Git &amp; GitHub Workshop</li> </ul>"},{"location":"workshops/arduino-uno-r4-matrix-display/","title":"Arduino Uno R4 Matrix Display Workshop","text":"<p>Arduino Uno R4 Matrix Display Workshop Github</p>"},{"location":"workshops/git-github/","title":"Git &amp; GitHub Workshop","text":"<p>https://github.com/UBIEEE/Git-GitHub-Workshop</p>"}]}